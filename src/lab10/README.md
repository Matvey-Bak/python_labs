# Стек (Stack)
## Что такое стек?
Стек — это фундаментальная структура данных, которая представляет собой упорядоченную коллекцию элементов, организованных по принципу 
LIFO (Last-In, First-Out), что переводится как "последним пришел, первым вышел". Это означает, что элемент, добавленный в стек 
последним, будет извлечен из него первым.

Представьте себе стопку книг или тарелок: вы можете положить новую книгу только наверх стопки и взять книгу тоже только сверху. Именно 
так работает стек — доступен только самый верхний элемент, а чтобы добраться до элементов внизу, нужно сначала удалить все элементы сверху.

## Основные характеристики стека
* Однонаправленный доступ — доступен только верхний элемент
* Динамический размер — стек может расти и уменьшаться
* Ограниченный набор операций — работа только с вершиной стека

## Типичные операции и их сложность
1. push(item) — добавление элемента
### Назначение: Добавляет новый элемент на вершину стека.
Сложность: O(1) — постоянное время
* Добавление происходит в конец списка/массива
* Не требует поиска или перестановки элементов
* Пример реализации на Python:
```python 
def push(self, item):
    self._data.append(item)  # O(1)
```

2. pop() — извлечение элемента
### Назначение: Удаляет и возвращает верхний элемент стека.

Сложность: O(1) — постоянное время
* Удаление происходит с конца списка/массива
* Не требует перемещения других элементов
* Пример:
```python
def pop(self):
    if self.is_empty():
        raise IndexError("Стек пуст")
    return self._data.pop()  # O(1)
```

3. peek() / top() — просмотр вершины
### Назначение: Возвращает верхний элемент без его удаления.

Сложность: O(1) — постоянное время
* Простое обращение к последнему элементу
* Не изменяет состояние стека
* Пример:
```python
def peek(self):
    if self.is_empty():
        return None
    return self._data[-1]  # O(1)
```

4. is_empty() — проверка на пустоту
### Назначение: Проверяет, содержит ли стек элементы.

Сложность: O(1) — постоянное время
* Проверка размера или сравнение с нулем
* Пример:
```python
def is_empty(self):
    return len(self._data) == 0  # O(1)
```

5. size() / __len__() — получение размера
### Назначение: Возвращает количество элементов в стеке.
Сложность: O(1) — постоянное время
* Хранение счетчика или использование встроенной функции
* Пример:
```python
def __len__(self):
    return len(self._data)  # O(1)
```

## Реализации стека
### Стек можно реализовать несколькими способами:
1. На основе массива/списка — самый распространенный способ. Массив растет динамически, вершина стека соответствует последнему элементу массива.
2. На основе связного списка — каждый элемент содержит данные и ссылку на следующий элемент. Вершина стека — это начало списка.
3. На основе массива фиксированного размера — используется реже, требует предварительного определения максимального размера.

## Практическое применение стеков
- Стеки широко используются в компьютерных науках и программировании:
- Управление вызовами функций — при вызове функции ее параметры и адрес возврата помещаются в стек. При возврате из функции эти данные извлекаются.
- Синтаксический анализ — проверка корректности вложенных конструкций (скобок, тегов HTML/XML).
- Алгоритмы обхода графов — поиск в глубину (DFS) использует стек для хранения вершин.
- Отмена операций — в текстовых редакторах и графических программах (Ctrl+Z).
- Вычисление выражений — преобразование и вычисление математических выражений.
- Рекурсивные алгоритмы — рекурсия неявно использует стек вызовов.

## Преимущества и ограничения
### Преимущества:
* Высокая скорость основных операций (O(1))
* Простота реализации и понимания
* Минимальные требования к памяти
* Естественное соответствие многим алгоритмическим задачам

### Ограничения:
* Ограниченный доступ (только к вершине)
* Неэффективный поиск элементов (O(n))
* Не подходит для задач, требующих произвольного доступа к элементам


# Очередь (Queue)

## Что такое очередь?

**Очередь** — это фундаментальная структура данных, которая представляет собой упорядоченную коллекцию элементов, организованных по принципу **FIFO** (First-In, First-Out), что переводится как "первым пришел, первым вышел". Это означает, что элемент, добавленный в очередь первым, будет извлечен из нее первым.

Представьте себе обычную очередь в магазине или на кассе: люди становятся в конец очереди и обслуживаются по порядку, начиная с первого. Именно так работает очередь — новые элементы добавляются в конец, а извлекаются из начала.

## Основные характеристики очереди

* **Двунаправленный доступ** — добавление происходит в конец, извлечение — из начала
* **Динамический размер** — очередь может расти и уменьшаться
* **Строгий порядок обслуживания** — элементы обрабатываются в порядке их поступления

## Типичные операции и их сложность

### 1. enqueue(item) — добавление элемента
**Назначение:** Добавляет новый элемент в конец очереди.

**Сложность:** O(1) — постоянное время
* Добавление происходит в конец структуры
* Не требует поиска или перестановки существующих элементов
* Пример реализации на Python:
```python
def enqueue(self, item):
    self._data.append(item)  # O(1) для deque
```

### 2. dequeue() — извлечение элемента
**Назначение:** Удаляет и возвращает первый элемент очереди.

**Сложность:** O(1) — постоянное время
* Удаление происходит из начала структуры
* Не требует перемещения других элементов
* Пример:
```python
def dequeue(self):
    if self.is_empty():
        raise IndexError("Очередь пуста")
    return self._data.popleft()  # O(1) для deque
```

### 3. peek() / front() — просмотр начала
**Назначение:** Возвращает первый элемент без его удаления.

**Сложность:** O(1) — постоянное время
* Простое обращение к первому элементу
* Не изменяет состояние очереди
* Пример:
```python
def peek(self):
    if self.is_empty():
        return None
    return self._data[0]  # O(1)
```

### 4. is_empty() — проверка на пустоту
**Назначение:** Проверяет, содержит ли очередь элементы.

**Сложность:** O(1) — постоянное время
* Проверка размера или сравнение с нулем
* Пример:
```python
def is_empty(self):
    return len(self._data) == 0  # O(1)
```

### 5. size() / __len__() — получение размера
**Назначение:** Возвращает количество элементов в очереди.

**Сложность:** O(1) — постоянное время
* Хранение счетчика или использование встроенной функции
* Пример:
```python
def __len__(self):
    return len(self._data)  # O(1)
```

## Реализации очереди

### Очередь можно реализовать несколькими способами:
1. **На основе двусторонней очереди (deque)** — самый эффективный способ в Python, позволяет добавлять и удалять элементы с обоих концов за O(1)
2. **На основе связного списка** — каждый элемент содержит данные и ссылку на следующий элемент, что позволяет эффективно удалять из начала
3. **На основе массива с круговой буферизацией** — эффективно использует память, но требует фиксированного размера или сложной логики расширения
4. **На основе двух стеков** — интересная академическая реализация, где один стек используется для добавления, другой — для удаления

## Практическое применение очередей

* **Планирование задач** — операционные системы используют очереди для планирования процессов
* **Обработка запросов** — веб-серверы обрабатывают HTTP-запросы в порядке их поступления
* **Буферизация данных** — в сетевых протоколах и потоках ввода-вывода
* **Алгоритмы обхода графов** — поиск в ширину (BFS) использует очередь для хранения вершин
* **Пул соединений** — управление подключениями к базам данных
* **Системы сообщений** — брокеры сообщений (RabbitMQ, Kafka) используют очереди
* **Печать документов** — задания на печать обрабатываются в порядке поступления

## Преимущества и ограничения

### Преимущества:
* Высокая скорость основных операций (O(1))
* Простота реализации и понимания
* Справедливое обслуживание (в порядке поступления)
* Широкий спектр применений в реальных системах

### Ограничения:
* Ограниченный доступ (только к началу и концу)
* Неэффективный поиск элементов (O(n))
* В некоторых реализациях может быть неэффективное использование памяти

---

# Односвязный список (Singly Linked List)

## Что такое односвязный список?

**Односвязный список** — это линейная структура данных, состоящая из последовательности узлов, где каждый узел содержит два поля: данные (value) и ссылку на следующий узел (next). Последний узел списка содержит ссылку на None (или null), обозначая конец списка.

Представьте себе цепочку людей, держащихся за руки: каждый человек знает только того, за чью руку он держится, но не знает, кто стоит дальше в цепочке. Чтобы найти конкретного человека, нужно пройти по цепочке от начала.

## Основные характеристики односвязного списка

* **Динамическая структура** — размер изменяется во время выполнения программы
* **Последовательный доступ** — для доступа к элементу нужно пройти все предыдущие
* **Распределенное хранение** — элементы могут быть разбросаны в памяти
* **Гибкость вставки/удаления** — можно легко вставлять и удалять элементы в любой позиции

## Типичные операции и их сложность

### 1. append(value) — добавление в конец
**Назначение:** Добавляет новый элемент в конец списка.

**Сложность:** O(1) с tail, O(n) без tail
* С хвостовым указателем: просто обновить tail.next
* Без хвостового указателя: нужно пройти весь список до конца
* Пример с tail:
```python
def append(self, value):
    new_node = Node(value)
    if self.head is None:
        self.head = new_node
        self.tail = new_node
    else:
        self.tail.next = new_node
        self.tail = new_node
    self._size += 1  # O(1)
```

### 2. prepend(value) — добавление в начало
**Назначение:** Добавляет новый элемент в начало списка.

**Сложность:** O(1) — постоянное время
* Создание нового узла и установка его как головы
* Пример:
```python
def prepend(self, value):
    new_node = Node(value)
    new_node.next = self.head
    self.head = new_node
    if self.tail is None:
        self.tail = new_node
    self._size += 1  # O(1)
```

### 3. insert(idx, value) — вставка по индексу
**Назначение:** Вставляет элемент на указанную позицию.

**Сложность:** O(n) в худшем случае
* Для вставки в середину нужно найти позицию
* Вставка в начало — O(1), в конец — O(1) с tail, в середину — O(n)
* Пример:
```python
def insert(self, idx, value):
    if idx < 0 or idx > self._size:
        raise IndexError("Индекс вне диапазона")
    
    if idx == 0:
        self.prepend(value)  # O(1)
    elif idx == self._size:
        self.append(value)  # O(1) с tail
    else:
        new_node = Node(value)
        current = self.head
        for _ in range(idx - 1):  # O(n)
            current = current.next
        new_node.next = current.next
        current.next = new_node
        self._size += 1
```

### 4. remove(value) — удаление по значению
**Назначение:** Удаляет первое вхождение указанного значения.

**Сложность:** O(n) — линейное время
* Требуется поиск элемента и его предыдущего узла
* Удаление из начала — O(1), из середины/конца — O(n)
* Пример:
```python
def remove(self, value):
    if self.head is None:
        return
    
    if self.head.value == value:  # O(1) для начала
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        self._size -= 1
        return
    
    current = self.head
    while current.next and current.next.value != value:  # O(n)
        current = current.next
    
    if current.next:
        current.next = current.next.next
        if current.next is None:
            self.tail = current
        self._size -= 1
```

### 5. Поиск элемента
**Назначение:** Проверяет наличие элемента в списке.

**Сложность:** O(n) — линейное время
* Требуется последовательный обход всех элементов
* Пример:
```python
def contains(self, value):
    current = self.head
    while current:  # O(n)
        if current.value == value:
            return True
        current = current.next
    return False
```

### 6. Доступ по индексу
**Назначение:** Получает элемент по указанному индексу.

**Сложность:** O(n) — линейное время
* Требуется последовательный проход от начала до нужной позиции
* Пример:
```python
def get(self, idx):
    if idx < 0 or idx >= self._size:
        raise IndexError("Индекс вне диапазона")
    
    current = self.head
    for _ in range(idx):  # O(n)
        current = current.next
    return current.value
```

## Реализации связного списка

### Односвязный список можно реализовать с различными оптимизациями:
1. **Базовая реализация** — только голова (head), добавление в конец за O(n)
2. **С хвостовым указателем (tail)** — добавление в конец за O(1)
3. **С охранным узлом (dummy node)** — упрощение обработки граничных случаев
4. **Кольцевой односвязный список** — последний узел ссылается на первый

## Практическое применение связных списков

* **Динамические структуры данных** — когда размер заранее неизвестен
* **Реализация стеков и очередей** — в качестве внутренней структуры
* **Управление памятью** — в системах сборки мусора
* **История операций** — в браузерах (кнопки "назад"/"вперед")
* **Плейлисты музыкальных треков** — последовательное воспроизведение
* **Текстовые редакторы** — представление строк как списка символов
* **Хэш-таблицы** — разрешение коллизий методом цепочек
* **Полиномы** — представление разреженных полиномов
* **Большие числа** — представление чисел произвольной длины

## Преимущества и ограничения

### Преимущества:
* Динамический размер — не требует предварительного выделения памяти
* Эффективные вставки/удаления в любом месте (O(1) при известной позиции)
* Не требует непрерывного блока памяти
* Легко расширяется и сжимается
* Идеален для операций с последовательным доступом

### Ограничения:
* Последовательный доступ — доступ к элементу за O(n)
* Больше памяти на элемент (хранится указатель next)
* Неэффективен для случайного доступа
* Сложнее в реализации и отладке, чем массивы
* Кэш-промахи из-за нелокальности данных в памяти

## Сравнение с массивом

| Критерий | Массив | Связный список |
|----------|--------|----------------|
| Доступ по индексу | O(1) | O(n) |
| Вставка в начало | O(n) | O(1) |
| Удаление из начала | O(n) | O(1) |
| Вставка в конец | O(1)* | O(1) с tail |
| Использование памяти | Более эффективно | Менее эффективно |
| Локальность данных | Высокая | Низкая |
| Динамический размер | Ограничен | Неограничен |

*\* O(1) амортизированное время для динамического массива*

Односвязный список — это мощная и гибкая структура данных, которая особенно полезна, когда важны частые вставки и удаления, а произвольный доступ к элементам не требуется.